<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>MConf: Matlab (or Python) Interface</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <meta name="author" content="Yuriy Turkin">
  <meta name="keywords" content="stellarator, w7x, W7-X, W7-X software">
  <meta name="description" content="W7-X Software">
  <link href="myCss.css" rel="stylesheet" type="text/css">
  <link href="tabs.css" rel="stylesheet" type="text/css" >
</head>
<body>
  <div class="centerAll" id="TopOfPage">
    <div class="bodyForAll">
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="MatlabInterface">Matlab (or Python) Interface </a></h1><dl class="user" compact><dt><b></b></dt><dd></dd></dl>
The <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> can be used from within Matlab environment (or from Python) by calling <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> functions from a shared library: from dll under Windows, or from so-library under Linux. The only thing one have to provide is the C interface to <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> classes because Matlab (Python) can not call C++ methods directly. The technique to accomplish this task is similar to that described in section <a class="el" href="MixedLanguage.html#FortranCallsC">Fortran calls C++</a>. At first a C++ object is created by a C function and the resulting address is returned to a caller. Then the caller passes this address along with the parameters to another C function to invoke required object's method.<p>
Below is a working example of how to write interface in C in order to call C++ functions from within Matlab (Python) environment.<p>
Header file; lines taken from <a class="el" href="mconf__matlab_8h.html">mconf_matlab.h</a> <div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef __CPP2MATLAB_</span>
<span class="preprocessor"></span><span class="preprocessor">#define __CPP2MATLAB_</span>
<span class="preprocessor"></span>
<span class="preprocessor">#if (defined( __unix__ ) || (defined(linux)) || defined(__sun) )</span>
<span class="preprocessor"></span><span class="preprocessor">  #define WINDLLEXPORT </span>
<span class="preprocessor"></span><span class="preprocessor">#elif defined( _WIN32 )</span>
<span class="preprocessor"></span><span class="preprocessor">  #define WINDLLEXPORT  __declspec( dllexport )</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef __GNUC__</span>
<span class="preprocessor"></span><span class="preprocessor"> #define __int64 int64_t </span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">//typedef __int64 MC_HANDLE;  // for 64-bit architecture</span>
<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <a class="code" href="mconf__matlab_8h.html#48621b882b89e8de21cfad30bdb03152">MC_HANDLE</a>;  <span class="comment">// for 32-bit architecture</span>

<span class="preprocessor">#ifdef __cplusplus</span>
<span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>  <a class="code" href="mconf__matlab_8h.html#fddebb4c234739845eee0fac51a51932">WINDLLEXPORT</a> MC_HANDLE <a class="code" href="mconf__matlab_8cpp.html#ec4aaf26898ae5c0379b0071d608fec8" title="The function loads the magnetic configuration stored in the file fname.">MCload</a>      (<span class="keywordtype">char</span> * fname);
  <a class="code" href="mconf__matlab_8h.html#fddebb4c234739845eee0fac51a51932">WINDLLEXPORT</a> <span class="keywordtype">void</span>   <a class="code" href="mconf__matlab_8cpp.html#432e4959479eb421dd3f1d405b853e6a" title="Free all memory used.">MCfree</a>  (MC_HANDLE mConf);
  <a class="code" href="mconf__matlab_8h.html#fddebb4c234739845eee0fac51a51932">WINDLLEXPORT</a> <span class="keywordtype">double</span> <a class="code" href="mconf__matlab_8cpp.html#5dbb6c0790ae30f425aded66fd5e76de" title="Get the B00 value of the magnetic field on axis.">MCgetB00</a>(MC_HANDLE mConf);
  <a class="code" href="mconf__matlab_8h.html#fddebb4c234739845eee0fac51a51932">WINDLLEXPORT</a> <span class="keywordtype">void</span>   <a class="code" href="mconf__matlab_8cpp.html#24d7c0a40fdd49791d2dec06ea3da075" title="Set the B00 value of magnetic field on magnetic axis.">MCsetB00</a>(MC_HANDLE mConf,<span class="keywordtype">double</span> B00);
<span class="preprocessor">#ifdef __cplusplus</span>
<span class="preprocessor"></span>}
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#endif  //  __CPP2MATLAB_</span>
</pre></div><p>
Implemention; lines taken from <a class="el" href="mconf__matlab_8cpp.html">mconf_matlab.cpp</a><p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "../include/C3dMesh.h"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "<a class="code" href="mconf__matlab_8h.html">mconf_matlab.h</a>"</span>

<span class="keyword">using</span> <a class="code" href="classMConf_1_1C3dMesh.html" title="This class tabulates magnetic field, flux surface label, grad(s) on a 3d-mesh in...">MConf::C3dMesh</a>;
<span class="keyword">using</span> <a class="code" href="classMConf_1_1CStconfig.html" title="Magnetic configuration of a stellarator.">MConf::CStconfig</a>;
<span class="keyword">using</span> <a class="code" href="classMConf_1_1Vector3d.html" title="This class provides 3d-vector type.">MConf::Vector3d</a>;

<span class="preprocessor">#undef True</span>
<span class="preprocessor"></span><span class="preprocessor">#undef False</span>
<span class="preprocessor"></span>
<span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="cpp2for_8cpp.html#cbf03ae8c87e9012e8672dafcd43fe17">True</a>(1);
<span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="cpp2for_8cpp.html#c24531c0377dc8fa65d2023bd88f2fe2">False</a>(0);

<span class="preprocessor">#ifdef __cplusplus</span>
<span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">//*********************************************************************</span>
<span class="comment">// constructor loads a file and returns the handle of the object </span>
<span class="comment">// with the magnetic configuration</span>
<a class="code" href="mconf__matlab_8h.html#fddebb4c234739845eee0fac51a51932">WINDLLEXPORT</a> MC_HANDLE <a class="code" href="mconf__matlab_8cpp.html#ec4aaf26898ae5c0379b0071d608fec8" title="The function loads the magnetic configuration stored in the file fname.">MCload</a>(<span class="keywordtype">char</span> * fname)
{
  C3dMesh * mc = <span class="keyword">new</span> C3dMesh;  
  MC_HANDLE mConf = (MC_HANDLE)mc;
  <span class="keywordtype">bool</span> ok = mc-&gt;load (fname);
  <span class="keywordflow">if</span>(!ok) {
    std::cout &lt;&lt; <span class="stringliteral">"MCLOAD: Loading error, file:'"</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">"'\n"</span>;
    <span class="keyword">delete</span> (mc);
    mConf = 0;    
  }
  <span class="keywordflow">return</span> mConf;
}

<span class="comment">//*********************************************************************</span>
<span class="comment">// destructor frees the memory occupied by the object with the handle mConf  </span>
<a class="code" href="mconf__matlab_8h.html#fddebb4c234739845eee0fac51a51932">WINDLLEXPORT</a> <span class="keywordtype">void</span> <a class="code" href="mconf__matlab_8cpp.html#432e4959479eb421dd3f1d405b853e6a" title="Free all memory used.">MCfree</a>(MC_HANDLE mConf)
{
  <span class="keywordflow">if</span> (mConf) <span class="keyword">delete</span> ((C3dMesh*)mConf);
}

<span class="comment">//*********************************************************************</span>
<span class="comment">// function returns B_00 from the object with the handle mConf  </span>
<a class="code" href="mconf__matlab_8h.html#fddebb4c234739845eee0fac51a51932">WINDLLEXPORT</a> <span class="keywordtype">double</span> <a class="code" href="mconf__matlab_8cpp.html#5dbb6c0790ae30f425aded66fd5e76de" title="Get the B00 value of the magnetic field on axis.">MCgetB00</a>(MC_HANDLE mConf)
{
  C3dMesh &amp;mc = *((C3dMesh*)mConf);
  <span class="keywordflow">return</span> mc.getB00();
}

<span class="comment">//*********************************************************************</span>
<span class="comment">// function passes B_00 to the object with the handle mConf  </span>
<a class="code" href="mconf__matlab_8h.html#fddebb4c234739845eee0fac51a51932">WINDLLEXPORT</a> <span class="keywordtype">void</span> <a class="code" href="mconf__matlab_8cpp.html#24d7c0a40fdd49791d2dec06ea3da075" title="Set the B00 value of magnetic field on magnetic axis.">MCsetB00</a>(MC_HANDLE mConf, <span class="keywordtype">double</span> B00)
{
  C3dMesh &amp;mc = *((C3dMesh*)mConf);
  mc.setB00(B00);
}

<span class="preprocessor">#ifdef __cplusplus</span>
<span class="preprocessor"></span>}
<span class="preprocessor">#endif</span>
</pre></div><p>
Finally the Matlab script is<p>
<div class="fragment"><pre class="fragment">
loadlibrary('mconf_matlab.dll','mconf_matlab.h');
libfunctions mconf_matlab -full; 
       
fname='w7x-sc1(reduced).bc';
% load the magnetic configuration file
% @return -- if the function succeeds, the return value is 
% the handle of MConf object;  zero otherwise.
MC = calllib('mconf_matlab','MCload',fname); 

%  test the MC before next calls, it must be non-zero

B00 = calllib('mconf_matlab','MCgetB00',MC);
B00 = 2.3;
calllib('mconf_matlab','MCsetB00',MC,B00);

calllib('mconf_matlab','MCfree',MC);

unloadlibrary mconf_matlab

</pre></div><p>
Python script:<p>
<div class="fragment"><pre class="fragment">

# This is working example of how to use the mconf.dll

# interfacing using numpy and ctypes.

import sys
import platform
import math
import numpy as np
import numpy.ctypeslib as npct
from ctypes import *

os = platform.system()
is_64bits = sys.maxsize &gt; 2**32

# load the library, using numpy mechanisms
if is_64bits:
  if os=='Windows':
    mconf = npct.load_library("mconf_matlab64.dll",".")
  elif os=='Linux':
    mconf = npct.load_library("mconf_matlab64.so",".")  
else:
  if os=='Windows':
    mconf = npct.load_library("mconf_matlab.dll",".")
  elif os=='Linux':
    mconf = npct.load_library("mconf_matlab.so",".")  

vec3 = npct.ndpointer(dtype=np.float64, ndim=1, flags='CONTIGUOUS')

# setup the return typs and argument types
mconf.MCload.restype = c_longlong  # for 64-bit architecture
mconf.MCload.argtypes = [c_char_p] 

mconf.MCgetRayIntersectionPoints.restype = c_int
mconf.MCgetRayIntersectionPoints.argtypes = [c_longlong,vec3,vec3,vec3,vec3]

mconf.MCgetB00.restype = c_double
mconf.MCgetB00.argtypes = [c_longlong]

mconf.MCsetB0.restype = c_double
mconf.MCsetB0.argtypes = [c_longlong,c_double,c_double]

mconf.MCgetBxyz.restype = c_double
mconf.MCgetBxyz.argtypes = [c_longlong,vec3,vec3]

mconf.MCVprime.restype = c_double
mconf.MCVprime.argtypes = [c_longlong,c_double]

mconf.MCVolume.restype = c_double
mconf.MCVolume.argtypes = [c_longlong,c_double]

mconf.MCtorFlux2polFlux.restype = c_double
mconf.MCtorFlux2polFlux.argtypes = [c_longlong,c_double]

fname=c_char_p("w7x-sc1beta=0.02.bc")
# load the magnetic configuration file
# @return -- if the function succeeds, the return value is 
# the address of C++ object;  zero otherwise.
mc = mconf.MCload(fname) # mc is like self in python
if mc == 0:
  print 'mconf: Could not load magnetic configuration'

B00 = mconf.MCgetB00(mc);
print B00 

# set magnetic field 2.5T at toroidal angle 0
##mconf.MCsetB0 (mc,c_double(2.5), c_double(0.));
B00 = mconf.MCgetB00(mc);
print B00 

# trace plasma along the ray through the port AEL41
# using Cartesian coordinates
r0 = np.array([-2.39133,-2.32718,-0.12071],dtype=np.float64)
r1 = np.array([-3.37847,-4.27681, 0.17038],dtype=np.float64)
rd = r1 - r0
rd = rd/np.sqrt(np.dot(rd,rd)) # normalize
print rd

# find entry point of the ray into plasma
entry= np.empty_like(r0) # ray entry
exit = np.empty_like(r0) # ray exit
retcode = mconf.MCgetRayIntersectionPoints(mc,r0,rd,entry,exit)
#  test retcode, it must be non-zero
if retcode == 0:
  print 'mconf: ray does not hit plasma'

print entry, exit, retcode

# ########################################################

maxPnt = 2000
dl = 0.01;     #  1cm
r0 = entry
          
# trace plasma along the ray
r = np.empty_like(r0)
rB = np.empty_like(r0)
for i in xrange(0,maxPnt):    
  lng  = i*dl          # length from r0 to r
  r = r0 + lng*rd      # move along the ray
  s = mconf.MCgetBxyz(mc,r,rB)
  if s&gt;1:  break     # break if not inside plasma
  V =  mconf.MCVolume(mc,c_double(s))  # V  is the  volume inside the surface s 
  Vp = mconf.MCVprime(mc,c_double(s)) # Vp is the  dV/ds 
  #x = sqrt(s)       # x is the normalized plasma radius x=reff/a  
  #n = ne(x)         # density
  #t = Te(x)         # temperature
  sPol = mconf.MCtorFlux2polFlux(mc,c_double(s)) # sPol is the normalized poloidal flux, where s is the normalized toroidal flux.
  print lng, s, sPol, rB 

  
mconf.MCmix2xyz.argtypes = [c_longlong,vec3,vec3]
 
# ****************************************************
# plot flux surface s=0.5 at cyl. angle 2degree 
phi = 2*6.28318531/360    # 2 degree 
s   = 0.5         

m = np.empty_like(r)
maxPnt = 200
dth =6.28318531/(maxPnt-1)
for i in range(0,maxPnt):    
  th = i*dth  
  m[0] = s
  m[1] = th
  m[2] = phi
  
  mconf.MCmix2xyz(mc,m,r)
  R = math.sqrt(r[0]**2+r[1]**2)
  Z = r[2]
  print R, Z  # cyl. coordinates R,Z
</pre></div><p>
The interfacing described above is employed in <a class="el" href="mconf__matlab_8cpp.html">mconf_matlab.cpp</a> and <a class="el" href="mconf__matlab_8h.html">mconf_matlab.h</a> </div>
    <p><a class="anchor" name="BottomOfPage"></a></p>
    <div class="no-print" align="right">
      <table border="0">
        <tr>
        <td>[ <a class="el" href="#TopOfPage">top</a> ]</td>
        <td>[ <a class="el" href="javascript:history.back(-1);"><b>back</b></a> ]</td> 
        </tr>
      </table>
    </div>
    <hr class="separator">
    <div class="ippAddress" align="right">
      <table border="0">
        <tr>
          <td class="ippAddress">13 Oct 2021 &nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td class="ippAddress">
            <a href="http://www.ipp.mpg.de"><img src="IPP.png" alt="www.ipp.mpg.de" border="0"></a>
          </td>
          <td class="ippAddress">
            <!-- Copyright &copy; 2005-2008<br> --> 
            Max-Planck-Institut<br>f&uuml;r Plasmaphysik
          </td>
        </tr>
      </table>
    </div>
  </div>
</div>
</body>
</html>
