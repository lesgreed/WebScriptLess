<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>MConf: Main Page</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <meta name="author" content="Yuriy Turkin">
  <meta name="keywords" content="stellarator, w7x, W7-X, W7-X software">
  <meta name="description" content="W7-X Software">
  <link href="myCss.css" rel="stylesheet" type="text/css">
  <link href="tabs.css" rel="stylesheet" type="text/css" >
</head>
<body>
  <div class="centerAll" id="TopOfPage">
    <div class="bodyForAll">
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1></h1>
<p>
<h1><a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> Library</h1>
<p>
<ul>
<li><a class="el" href="index.html#WhatItDoes">What it does</a></li><li><a class="el" href="index.html#WhatItDoesNot">What it doesn't do</a></li><li><a class="el" href="index.html#FluxCoordinates">Flux Coordinates</a><ul>
<li><a class="el" href="index.html#VmecCoordinates">Vmec Coordinates</a><ul>
<li><a class="el" href="index.html#PESTCoordinates">PEST coordinates</a></li></ul>
</li><li><a class="el" href="index.html#BoozerCoordinates">Boozer Coordinates</a></li><li><a class="el" href="index.html#TokamakSymmetryFluxCoordinates">Tokamak Symmetry Flux Coordinates</a></li></ul>
</li><li><a class="el" href="index.html#CoordinateTransformation">Coordinate Transformation</a><ul>
<li><a class="el" href="index.html#VMEC2Boozer">Transformation from VMEC to Boozer Coordinates</a></li><li><a class="el" href="index.html#Cyl2Mag">Transformation from cylindrical to flux Coordinates</a><ul>
<li><a class="el" href="index.html#NewtonMethod">Newton method</a></li></ul>
</li></ul>
</li></ul>
<p>
<br>
<p>
<ul>
<li><a class="el" href="index.html#Gettingstarted">Getting started</a><ul>
<li><a class="el" href="index.html#MinimalExample">Minimal example</a></li><li><a class="el" href="index.html#ObjectCanBeCopied">Objects can be copied</a></li><li><a href="examples.html" class="el">Other examples</a></li></ul>
</li><li><a class="el" href="index.html#RelatedProjects">Related Projects</a><ul>
<li><a href="../docs-mcviewer/index.html" class="el">MCviewer - Magnetic Configuration viewer</a></li><li><a class="el" href="Screenshots.html#Travis">Travis</a></li><li><a class="el" href="Screenshots.html#NBIviewer">NBIviewer</a></li></ul>
</li><li><a class="el" href="References.html">References</a></li><li><a class="el" href="SoftwareLicense.html">Software License</a></li></ul>
<p>
<br>
<p>
<ul>
<li><a class="el" href="MixedLanguage.html">Mixed-language programming</a><ul>
<li><a class="el" href="cpp2for_8cpp-example.html">Fortran calls MConf (cpp2for.cpp)</a></li></ul>
</li><li><a class="el" href="MatlabInterface.html">Matlab (or Python) Interface</a><ul>
<li><a class="el" href="mconf__matlab_8h.html">Functions</a></li></ul>
</li></ul>
<p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><p>
<b><a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a></b> stands for Magnetic Configuration. The goal of this library is to provide fast and convenient tools for coordinate transformations between flux coordinates and real space coordinates. Here you will find the description of CStconfig, CRayTrace, and C3dMesh classes, which comprise the package <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a>. An C++ <a href="examples.html" class="el">examples</a> and example <a class="el" href="cpp2for_8cpp.html">cpp2for.cpp</a> of how to write interface C-functions (see also <a class="el" href="MixedLanguage.html">Mixed-language programming</a>) in order to call C++ methods from within FORTRAN programs are available.<h2><a class="anchor" name="WhatItDoes">
What it does</a></h2>
The input file for the <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> is the Boozer magnetic configuration file which is the result of VMEC code and JMC/xbooz_xform codes. However, <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> understands VMEC wout-file, in this case <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> uses VMEC coordinates. Magnetic configuration can be loaded also from <a class="el" href="MCDB.html">Magnetic Configuration Database</a>.<p>
<a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> makes available numerous information about magnetic configuration of a stellarator or tokamak: magnetic field, Jacobian, iota, trapped particle fraction, minimum and maximum magnetic field on a flux surface, volume inside flux surface, and so on. The package contains programs for straight line tracing through flux surfaces. <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> can also create 3d-mesh in cylindrical coordinates on which it tabulates magnetic field, flux surface label <em>s</em>, grad(s) and provides functions for interpolation. The mesh and magnetic configuration can be stored in a file for future loading.<p>
Due to object oriented approach this package easy to use in other application; for example, the visualization program <a href="../docs-mcviewer/index.html" class="el">MCviewer</a>, which displays various aspects of a magnetic configuration, has been created using the library <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a>. The library is written in C++, interface routines for using <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> from within FORTRAN are provided. The library can be used in Multithreaded Applications, see <a href="examples.html" class="el">examples</a>. <br>
<p>
In short, <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> features are:<p>
<p>
<ul>
<li>load function, supported formats:<ul>
<li><a class="el" href="W7X_Format.html">W7-X</a> by J. Geiger</li><li>LHD <a class="el" href="References.html">[6]</a></li><li>VMEC wout text file <a class="el" href="References.html">[4]</a></li><li><a class="el" href="GEQDSK.html">EFIT G EQDSK</a></li><li>proprietary binary format (bin4, bin8)</li></ul>
</li><li>save function, supported formats:<ul>
<li><a class="el" href="W7X_Format.html">W7-X</a></li><li>proprietary binary format (bin4, bin8)</li></ul>
</li><li>data base operation<ul>
<li>load/delete/insert magnetic configuration from/to <a class="el" href="MCDB.html">Magnetic Configuration Data Base</a></li></ul>
</li><li>functions for:<ul>
<li>coordinate transformation from real to flux coordinates: forth and back</li><li>coordinate transformation from VMEC to Boozer coordinates</li><li>inquire position (inside or outside LCMS or relative to the given contour)</li><li>surface quantity: <b>B</b>, B<sub>min</sub>, B<sub>max</sub>, Jacobian, iota, V, V',I<sub>tor</sub> , I<sub>pol</sub>, grad(r<sub>eff</sub>), Fourier coefficients</li><li>remeshing to decrease number of flux surfaces and truncate spectrum</li><li>straight line ray tracing to find intersection of a ray with the flux surface</li><li>3d-mesh generator which tabulates magnetic field, flux surface label <em>s</em>, grad(r<sub>eff</sub>) on a 3d-mesh in cylindrical coordinates and provides functions for interpolation. The mesh and its functions can be used time consuming computing (NBI modeling(including Monte-Carlo), ECE and ECRH Ray tracing)</li><li>mesh generator can be started in several threads thus utilizing extra cores in modern processors, for example, Intel Core&trade; 2 Duo or Intel Core&trade; 2 Quad, see <a class="el" href="classMConf_1_1C3dMesh.html#387ca2dd6d15b299fdbe4b19a2042b6c" title="The method creates 3d-mesh in cylindrical coordinates.">MConf::C3dMesh::createMesh()</a></li><li>function for saving and loading 3d-mesh or magnetic configuration file in binary format for faster loading in future use</li><li>calculating<ul>
<li>effective helical ripple <a class="el" href="classMConf_1_1CStconfig.html#037f4dbd0a2a0a1c42c6138a707f324a" title="The method returns the effective helical ripple for  transport, using VMEC definition...">MConf::C3dMesh::epsEffVmec()</a></li><li>gradB drift velocity of trapped particles <a class="el" href="classMConf_1_1CStconfig.html#b89f959f8c7cdbadb7d1ba2dab32d15f" title="The methods return the bounce-averade gradB drift velocity of trapped particles averaged...">MConf::C3dMesh::Gv()</a></li><li>bootstrap current geometric factor <a class="el" href="classMConf_1_1CStconfig.html#c18db696515c9ecd990436fcdf657db3" title="The method returns the bootstrap current geometric factor for  transport, using VMEC...">MConf::C3dMesh::FbsVmec()</a></li></ul>
</li></ul>
</li></ul>
<p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h2><a class="anchor" name="WhatItDoesNot">
What it doesn't do</a></h2>
<a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> doesn't reconstruct or calculate equilibrium, but uses VMEC(VMEC based) or EFIT EQDSK equilibrium.<br>
<p>
<a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> can't work outside the last closed magnetic surface (LCMS); LCMS is the surface with the flux suface label <em>s</em> = 1, where <em>s</em> is the normalized toroidal flux.<p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h2><a class="anchor" name="FluxCoordinates">
Flux Coordinates</a></h2>
Flux coordinates concept is very fundamental and convenient tools for describing complex geometry of plasma in tokamaks or stellarators <a class="el" href="References.html">[1]</a>. These coordinates are aligned with the magnetic field structure that represents the set of nested magnetic (or flux) surfaces of a toroidal type. The surfaces are enumerated by the flux surface label or effective plasma radius; usually that is a quantity derived from the poloidal or toroidal magnetic flux value enclosed by the flux surface. To define position on a flux surfaces the two angle-like variables <img class="formulaInl" alt="$(\theta,\varphi)$" src="form_25.png"> are used. The flux coordinates in which these angles are chosen in such a way that the magnetic field lines are straight lines on the <img class="formulaInl" alt="$(\theta,\varphi)$" src="form_25.png"> plane are called magnetic coordinates.<h3><a class="anchor" name="VmecCoordinates">
Vmec Coordinates</a></h3>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> can interpret the VMEC <a class="el" href="References.html">[4]</a> wout-file version 6.20 and higher. Present version of the library handle VMEC equilibria in stellarator symmetric mode only. VMEC toroidal angle coincides with cylindrical angle and additionally VMEC provides the stream function <img class="formulaInl" alt="$\lambda$" src="form_1.png"> that helps to build straight field line coordinates system<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{B}=\frac{\psi_{lcms}}{2\pi}\left(\nabla s\times\nabla\theta^{*}+ \iota(s)\nabla\varphi\times\nabla s\right) \]" src="form_26.png">
<p>
<p>
with <img class="formulaInl" alt="$\theta^{*}=\theta+\lambda(s,\theta,\varphi)$" src="form_27.png"><p>
The flux coordinates <img class="formulaInl" alt="$(s,\theta,\varphi)$" src="form_28.png"> are defined by giving the cylindrical coordinates as functions of the flux coordinates<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} r(s,\theta,\varphi) &amp;=&amp; \sum_{m=0}^M\sum_{n=-N}^{N}R_{mn}(s)\cos\left(m\theta-nN_{p}\varphi\right)\\ \phi(s,\theta,\varphi) &amp;=&amp; \varphi\\ z(s,\theta,\varphi) &amp;=&amp; \sum_{m=0}^{M}\sum_{n=-N}^{N}Z_{mn}(s)\sin\left(m\theta-nN_{p}\varphi\right)\\ \lambda(s,\theta,\varphi) &amp;=&amp; \sum_{m=0}^{M}\sum_{n=-N}^{N}\lambda_{mn}(s)\sin\left(m\theta-nN_{p}\varphi\right) \end{eqnarray*}" src="form_29.png">
<p>
<p>
The Jacobian and magnetic field are calculated using formulas<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} J(s,\theta,\varphi) &amp;=&amp; \sum_{m=0}^{M}\sum_{n=-N}^{N}g_{mn}(s)\cos\left(m\theta-nN_{p}\varphi\right)\\ \mathbf{B}(s,\theta,\varphi) &amp;=&amp;\frac{\psi_{lcms}}{2\pi J}\left[\frac{\partial\mathbf{X}}{\partial\varphi} \left(1+\frac{\partial\lambda}{\partial\theta}\right)+ \frac{\partial\mathbf{X}}{\partial\theta}\left(\iota- \frac{\partial\lambda}{\partial\varphi}\right)\right] \end{eqnarray*}" src="form_30.png">
<p>
<p>
B-field line <img class="formulaInl" alt="$(s_{0},\theta,\varphi)$" src="form_31.png"> going through the point <img class="formulaInl" alt="$(s_{0},\theta_{0},\varphi_{0})$" src="form_32.png"> is defined by expression<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \theta(\varphi)=\theta_{0}+\iota(s_{0})(\varphi-\varphi_{0}) - [\lambda(s_{0},\theta,\varphi)-\lambda(s_{0},\theta_{0},\varphi_{0})] \]" src="form_33.png">
<p>
<p>
Both methods can be applied to follow field line:<p>
<ul>
<li><a class="el" href="classMConf_1_1CStconfig.html#d996bc4266de8a45c4809d65181da743" title="The method returns magnetic coordinates of the point of a field line, that passes...">MConf::C3dMesh::magCoordFieldLine()</a> uses cylindrical angle,</li><li><a class="el" href="classMConf_1_1CStconfig.html#428bcdd632a30b021370f9336ffc8888" title="The method returns magnetic coordinates of the point of a field line, that passes...">MConf::C3dMesh::mixCoordFieldLine()</a> uses cylindrical angle.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd></dd></dl>
Recently J. Geiger and I have discovered that even VMEC 2000 produces slightly different output.<p>
Reading the wout-file created by VMEC in use by J. Geiger.<p>
<div class="fragment"><pre class="fragment">! full-mesh quantities
  read(iunit,*)(iotaf(j),presf(j),phipf(j),phi(j),jcuru(j),jcurv(j),j=1,ns)
! half-mesh quantities 
  read(iunit,*)(iotas(j),mass(j),pres(j),beta_vol(j),phip(j),buco(j),bvco(j), &amp;
    vp(j),overr(j),specw(j),j=2,ns)
</pre></div><p>
Reading the file created by VMEC in use by PPPL.<p>
<div class="fragment"><pre class="fragment">! half-mesh quantities (except phi, jcuru, jcurv which are on full-mesh)
  read(iwout,*)(iotas(j),mass(j),pres(j),beta_vol(j),phip(j),buco(j),bvco(j), phi(j), &amp;
     vp(j),overr(j),jcuru(j),jcurv(j),specw(j),j=2,ns)
</pre></div><p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h4><a class="anchor" name="PESTCoordinates">
PEST coordinates</a></h4>
The straight-field-line coordinates system that uses the cylindrical angle <img class="formulaInl" alt="$\phi$" src="form_34.png"> as the toroidal angle in tokamak literature is called PEST <a class="el" href="References.html">[7]</a> coordinates.<p>
In case of VMEC input file these coordinates, <img class="formulaInl" alt="$(s,\theta^{*},\phi)$" src="form_35.png"> , can be easily build from <a class="el" href="index.html#VmecCoordinates">Vmec Coordinates</a> and its stream function <img class="formulaInl" alt="$\lambda$" src="form_1.png"> using transformation<p>
<img class="formulaInl" alt="$\theta^{*}=\theta+\lambda(s,\theta,\phi)$" src="form_36.png"><p>
The following methods perform transformation between the PEST and VMEC coordinates:<p>
<a class="el" href="classMConf_1_1CStconfig.html#ab04c804ead818e1aa22410f3660fcb9" title="VMEC coordinates vmecCoord=(s,theta,phi).">MConf::CStconfig::Vmec2Pest()</a> <br>
 <a class="el" href="classMConf_1_1CStconfig.html#1cba9a2908bf641ea19de25d20bbdd6e">MConf::CStconfig::Pest2Vmec()</a> <br>
<p>
The method returns contravariant-basis vectors <img class="formulaInl" alt="$(\nabla s, \nabla \theta^{*}, \nabla \phi)$" src="form_37.png"> in cylindrical coordinates:<p>
<a class="el" href="classMConf_1_1CStconfig.html#c17e3819bea9151989ba798ffa3b0678">MConf::CStconfig::SFLcontraBasis()</a> <br>
<p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h3><a class="anchor" name="BoozerCoordinates">
Boozer Coordinates</a></h3>
In Boozer coordinates, the contravariant and covariant components of the magnetic field are defined through the expressions <a class="el" href="References.html">[1,2]</a>:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{B}=\frac{1}{2\pi}\left(\nabla\psi\times\nabla\theta+ \iota(\psi)\nabla\varphi\times\nabla\psi\right) \]" src="form_38.png">
<p>
<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{B}=\frac{\mu_{0}}{2\pi}\left(I_{pol}(\psi)\nabla\varphi+ I_{tor}(\psi)\nabla\theta+\beta_{*}\nabla\psi\right) \]" src="form_39.png">
<p>
 where <img class="formulaInl" alt="$(\psi,\theta,\varphi)$" src="form_40.png"> are the toroidal flux, poloidal, and toroidal angles; <img class="formulaInl" alt="$0\leq\psi\leq\psi_{lcms}$" src="form_41.png"> (<img class="formulaInl" alt="$\psi=0$" src="form_42.png"> at the magnetic axis), <img class="formulaInl" alt="$0\leq\theta\leq2\pi$" src="form_43.png">, <img class="formulaInl" alt="$0\leq\varphi\leq2\pi$" src="form_44.png">.<p>
The magnetic coordinate system <img class="formulaInl" alt="$(\psi,\theta,\varphi)$" src="form_40.png"> is defined by giving the cylindrical coordinates as functions of magnetic coordinates, i.e. the cylindrical coordinates of a point on a magnetic surface and the magnetic field value are:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} r(\psi,\theta,\varphi) &amp;=&amp; \sum_{m=0}^M\sum_{n=-N}^{N}R_{mn}(\psi)\cos\left(m\theta-nN_{p}\varphi\right)\\ \phi(\psi,\theta,\varphi) &amp;=&amp; \varphi-\frac{2\pi}{N_{p}}\sum_{m=0}^{M}\sum_{n=-N}^{N}\Phi_{mn}(\psi)\sin\left(m\theta-nN_{p}\varphi\right)\\ z(\psi,\theta,\varphi) &amp;=&amp; \sum_{m=0}^{M}\sum_{n=-N}^{N}Z_{mn}(\psi)\sin\left(m\theta-nN_{p}\varphi\right)\\ B(\psi,\theta,\varphi) &amp;=&amp; \sum_{m=0}^{M}\sum_{n=-N}^{N}B_{mn}(\psi)\cos\left(m\theta-nN_{p}\varphi\right) \end{eqnarray*}" src="form_45.png">
<p>
<p>
where <img class="formulaInl" alt="$N_p$" src="form_46.png"> is the number of field periods.<p>
Poloidal and toroidal currents <img class="formulaInl" alt="$I_{pol},\:I_{tor}$" src="form_47.png"> and Fourier coefficients <img class="formulaInl" alt="$R_{mn},\:\Phi_{mn},\:Z_{mn},\:B_{mn}$" src="form_48.png"> are stored in a <a class="el" href="W7X_Format.html">Boozer file</a>. This information is enough to calculate the Jacobian and magnetic field using formulas<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} J(\psi,\theta,\varphi) &amp;=&amp; \frac{\mu_{0}}{4\pi^{2}}\frac{I_{pol}+\iota I_{tor}}{B^{2}}\\ \mathbf{B}(\psi,\theta,\varphi) &amp;=&amp; \frac{1}{2\pi J}\left(\frac{\partial\mathbf{X}}{\partial\varphi}+ \iota\frac{\partial\mathbf{X}}{\partial\theta}\right) \end{eqnarray*}" src="form_49.png">
<p>
<p>
where <b>X</b> is the spatial position given by<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{X}=r(\psi,\theta,\varphi)\cos(\phi)\mathbf{\hat{x}}+ r(\psi,\theta,\varphi)\sin(\phi)\mathbf{\hat{y}}+ z(\psi,\theta,\varphi)\hat{\mathbf{z}} \]" src="form_50.png">
<p>
<p>
<a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> library uses normalized toroidal flux <img class="formulaInl" alt="$s=\psi/\psi_{lcms}$" src="form_51.png"> as a flux surface label, which is zero on a magnetic axes and one at the LCMS. The flux surface label <em>s</em> is the same as in original VMEC file. Then expressions for the Jacobian and magnetic field are as follows<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} J_{s}(s,\theta,\varphi) &amp;=&amp; \frac{\mu_{0} \psi_{lcms}}{4\pi^{2}}\frac{I_{pol}+\iota I_{tor}}{B^{2}}\\ \mathbf{B}(s,\theta,\varphi) &amp;=&amp; \frac{\psi_{lcms}}{2\pi J_{s}}\left(\frac{\partial\mathbf{X}}{\partial\varphi}+ \iota\frac{\partial\mathbf{X}}{\partial\theta}\right) \end{eqnarray*}" src="form_52.png">
<p>
<p>
Boozer coordinate system represent the magnetic coordinates, so the B-field line going through the point <img class="formulaInl" alt="$(s_{0},\theta_{0},\varphi_{0})$" src="form_32.png"> is defined by linear expression<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \theta(\varphi)=\theta_{0}+\iota(s_{0})(\varphi-\varphi_{0}) \]" src="form_53.png">
<p>
<p>
There are two library methods that can be applied to follow field line:<p>
<ul>
<li><a class="el" href="classMConf_1_1CStconfig.html#d996bc4266de8a45c4809d65181da743" title="The method returns magnetic coordinates of the point of a field line, that passes...">MConf::C3dMesh::magCoordFieldLine()</a> uses Boozer toroidal angle,</li><li><a class="el" href="classMConf_1_1CStconfig.html#428bcdd632a30b021370f9336ffc8888" title="The method returns magnetic coordinates of the point of a field line, that passes...">MConf::C3dMesh::mixCoordFieldLine()</a> uses cylindrical angle.</li></ul>
<p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h3><a class="anchor" name="TokamakSymmetryFluxCoordinates">
Tokamak Symmetry Flux Coordinates</a></h3>
<a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> can import equilibrium from <a class="el" href="GEQDSK.html">G EQDSK File</a> into straight-field-line coordinates system with the symmetry angle <img class="formulaInl" alt="$\phi$" src="form_34.png"> as the toroidal angle <img class="formulaInl" alt="$\varphi$" src="form_54.png">. This coordinate system is called Tokamak Symmetry Flux Coordinates in <a class="el" href="References.html">[1]</a>. Other name of this system is the PEST coordinates <a class="el" href="References.html">[7]</a>.<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{B}=\frac{1}{2\pi}\left(\nabla\psi\times\nabla\theta+\iota(\psi)\nabla\varphi\times\nabla\psi\right) \]" src="form_55.png">
<p>
 or in the form used in the tokamak literature <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{B}=\mathbf{B_{\mathit{tor}}}+\mathbf{B_{\mathrm{\mathit{pol}}}}= \frac{1}{2\pi}\left(\mu_{0}I_{pol}(\psi)\nabla\varphi+ \iota(\psi)\nabla\varphi\times\nabla\psi\right) \]" src="form_56.png">
<p>
<p>
In <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a>, the magnetic coordinates <img class="formulaInl" alt="$(s,\theta,\varphi)$" src="form_28.png"> are defined as a Fourier decomposition by giving the cylindrical coordinates as functions of magnetic coordinates<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} r(s,\theta,\varphi) &amp;=&amp; \sum_{m=0}^M\sum_{n=0}^{1}R_{mn}(s)\cos\left(m\theta-n\frac{\pi}{2}\right)\\ \phi(s,\theta,\varphi) &amp;=&amp; \varphi\\ z(s,\theta,\varphi) &amp;=&amp; \sum_{m=0}^{M}\sum_{n=0}^{1}Z_{mn}(s)\sin\left(m\theta-n\frac{\pi}{2}\right)\\ \end{eqnarray*}" src="form_57.png">
<p>
<p>
With this representation (summation over <em>n</em> from 0 to 1) the tokamak equilibrium from <a class="el" href="GEQDSK.html">G EQDSK File</a> can be saved in <a class="el" href="W7X_Format.html">W7-X format</a>, where <img class="formulaInl" alt="$n \pi/2$" src="form_58.png"> term provides sin and cos terms in expansions. The coefficients <img class="formulaInl" alt="$R_{mn},\:Z_{mn}$" src="form_59.png"> are calculated by B-field line tracing while creating straight-field-line coordinates system.<p>
Fourier decomposition of the tokamak equilibrium allows us to use all MConf-library functions without need to be rewritten; the Jacobian is only different. The import is provided by class <a class="el" href="classMConf_1_1CEfit.html" title="Helper class that reads EFIT GEQDSK file and transforms it to the Tokamak Symmetry...">MConf::CEfit</a>.<p>
The Jacobian and magnetic field are calculated using formulas<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} J(s,\theta,\varphi) &amp;=&amp; \frac{\psi_{lcms} r^2}{\mu_{0}I_{pol}}\\ \mathbf{B}(s,\theta,\varphi) &amp;=&amp; \frac{\psi_{lcms}}{2\pi J}\left(\frac{\partial\mathbf{X}}{\partial\varphi}+ \iota\frac{\partial\mathbf{X}}{\partial\theta} \right) \end{eqnarray*}" src="form_60.png">
<p>
<p>
Poloidal current <img class="formulaInl" alt="$I_{pol}=2\pi rB_{tor}/\mu_{0}$" src="form_61.png"> is provided by G EQDSK File.<p>
B-field line <img class="formulaInl" alt="$(s_{0},\theta,\varphi)$" src="form_31.png"> going through the point <img class="formulaInl" alt="$(s_{0},\theta_{0},\varphi_{0})$" src="form_32.png"> is defined by expression<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \theta(\varphi)=\theta_{0}+\iota(s_{0})(\varphi-\varphi_{0}) \]" src="form_53.png">
<p>
<p>
Both methods can be applied to follow field line:<p>
<ul>
<li><a class="el" href="classMConf_1_1CStconfig.html#d996bc4266de8a45c4809d65181da743" title="The method returns magnetic coordinates of the point of a field line, that passes...">MConf::C3dMesh::magCoordFieldLine()</a> uses cylindrical angle,</li><li><a class="el" href="classMConf_1_1CStconfig.html#428bcdd632a30b021370f9336ffc8888" title="The method returns magnetic coordinates of the point of a field line, that passes...">MConf::C3dMesh::mixCoordFieldLine()</a> uses cylindrical angle.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd></dd></dl>
To distinguish this coordinates from "true" <a class="el" href="W7X_Format.html">W7-X format</a> the following comment string<p>
<div class="fragment"><pre class="fragment"> CC Tokamak Symmetry Flux Coordinates 
</pre></div><p>
is written into files exported by <a class="el" href="classMConf_1_1CStconfig.html#d422aa8c290ef1797be09817ecc6686d" title="Store current magnetic configuration into file.">MConf::CStconfig::write</a>, <a class="el" href="classMConf_1_1CStconfig.html#5ff612ea1be83bd73c096ccf7d2a3172" title="The methods transform the current magnetic configuration to new volume or to new...">MConf::CStconfig::writeasciiReduced</a><p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h2><a class="anchor" name="CoordinateTransformation">
Coordinate Transformation</a></h2>
<h3><a class="anchor" name="VMEC2Boozer">
Transformation from VMEC to Boozer Coordinates</a></h3>
Substituting the Boozer angles <img class="formulaInl" alt="$(\theta_{B}, \varphi_{B})$" src="form_62.png"> expressed through the VMEC angles <img class="formulaInl" alt="$(\theta_{V}, \varphi_{V})$" src="form_63.png"><p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \theta_{B} &amp; = &amp; \theta_{V}+\lambda(s,\theta_{V},\varphi_{V})+\iota h(s,\theta_{V},\varphi_{V})\\ \varphi_{B} &amp; = &amp; \varphi_{V}+h(s,\theta_{V},\varphi_{V}) \end{eqnarray*}" src="form_64.png">
<p>
<p>
into the covariant representation of the magnetic field in <a class="el" href="index.html#BoozerCoordinates">Boozer Coordinates</a> we obtain the equation for determining the double-periodic transformation function <img class="formulaInl" alt="$h$" src="form_65.png"><p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{B}=\frac{\mu_{0}}{2\pi}\left[I_{pol}\nabla\varphi_{V}+I_{tor}\left(\nabla\theta_{V}+\nabla\lambda\right)+ \left(I_{pol}+\iota I_{tor}\right)\nabla h+\left(\beta_{*}+I_{tor}h\frac{d\iota}{d\psi}\right)\nabla\psi\right] \]" src="form_66.png">
<p>
<p>
The above expression yields the following covariant components of the magnetic field in VMEC coordinates:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ B_{\theta_{V}}=\frac{\mu_{0}}{2\pi}\left[I_{tor}+I_{tor}\frac{\partial\lambda}{\partial\theta_{V}}+\left(I_{pol}+ \iota I_{tor}\right)\frac{\partial h}{\partial\theta_{V}}\right] \]" src="form_67.png">
<p>
<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ B_{\varphi_{V}}=\frac{\mu_{0}}{2\pi}\left[I_{pol}+I_{tor}\frac{\partial\lambda}{\partial\varphi_{V}}+ \left(I_{pol}+\iota I_{tor}\right)\frac{\partial h}{\partial\varphi_{V}}\right] \]" src="form_68.png">
<p>
<p>
from which the Fourier coefficients <img class="formulaInl" alt="$h_{mn}$" src="form_69.png"> of the angle transformation function <img class="formulaInl" alt="$h$" src="form_65.png"> are expressed through the known VMEC quantities:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} h_{00} &amp; = &amp; 0\\ I_{tor}\lambda_{mn}+\left(I_{pol}+\iota I_{tor}\right)h_{mn} &amp; = &amp; \frac{2\pi}{\mu_{0}} \frac{1}{m} \left(B_{\theta_{V}}\right)_{mn}\,\,\, if\, m\neq0\\ &amp; = &amp; -\frac{2\pi}{\mu_{0}} \frac{1}{nN_p} \left(B_{\varphi_{V}}\right)_{mn}\,\,\, if\, n\neq0 \end{eqnarray*}" src="form_70.png">
<p>
<p>
The Boozer spectra of quantities of interest are calculated by integrating over the Boozer angles<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} B_{mn}^{B} &amp; = &amp; \frac{1}{2\pi^2}\int^{2\pi}_0 \int^{2\pi}_0 d\theta_B d\varphi_B\, cos(m\theta_B - nN_p\varphi_B)\,B(\theta_B,\varphi_B)\\ R_{mn}^{B} &amp; = &amp; \frac{1}{2\pi^2}\int^{2\pi}_0 \int^{2\pi}_0 d\theta_B d\varphi_B\, cos(m\theta_B - nN_p\varphi_B)\,r(\theta_B,\varphi_B)\\ Z_{mn}^{B} &amp; = &amp; \frac{1}{2\pi^2}\int^{2\pi}_0 \int^{2\pi}_0 d\theta_B d\varphi_B\,sin(m\theta_B - nN_p\varphi_B)\,z(\theta_B,\varphi_B)\\ \frac{2\pi}{nN_p}\Phi_{mn}^{B} &amp; = &amp; \frac{1}{2\pi^2}\int^{2\pi}_0 \int^{2\pi}_0 d\theta_B d\varphi_B\,sin(m\theta_B - nN_p\varphi_B)\,h(\theta_B,\varphi_B)\\ \end{eqnarray*}" src="form_71.png">
<p>
<p>
or VMEC angles<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} B_{mn}^{B} &amp; = &amp; \frac{1}{2\pi^2}\int^{2\pi}_0 \int^{2\pi}_0 d\theta_V d\varphi_V\, \frac{\partial(\theta_B,\varphi_B)}{\partial(\theta_V,\varphi_V)}\, cos(m\theta_B - nN_p\varphi_B)\,B(\theta_V,\varphi_V)\\ R_{mn}^{B} &amp; = &amp; \frac{1}{2\pi^2}\int^{2\pi}_0 \int^{2\pi}_0 d\theta_V d\varphi_V\, \frac{\partial(\theta_B,\varphi_B)}{\partial(\theta_V,\varphi_V)}\, cos(m\theta_B - nN_p\varphi_B)\,r(\theta_V,\varphi_V)\\ Z_{mn}^{B} &amp; = &amp; \frac{1}{2\pi^2}\int^{2\pi}_0 \int^{2\pi}_0 d\theta_V d\varphi_V\,\frac{\partial(\theta_B,\varphi_B)}{\partial(\theta_V,\varphi_V)}\, sin(m\theta_B - nN_p\varphi_B)\,z(\theta_V,\varphi_V)\\ \frac{2\pi}{nN_p}\Phi_{mn}^{B} &amp; = &amp; \frac{1}{2\pi^2}\int^{2\pi}_0 \int^{2\pi}_0 d\theta_V d\varphi_V\,\frac{\partial(\theta_B,\varphi_B)}{\partial(\theta_V,\varphi_V)}\, sin(m\theta_B - nN_p\varphi_B)\,h(\theta_V,\varphi_V)\\ \end{eqnarray*}" src="form_72.png">
<p>
<p>
where <img class="formulaInl" alt="$m=0..M,\, n=-N..N,$" src="form_73.png"> <img class="formulaInl" alt="$R_{00}^B=R_{mn}^B/2,$" src="form_74.png"> <img class="formulaInl" alt="$B_{00}^B=B_{mn}^B/2,$" src="form_75.png"> and<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial(\theta_B,\varphi_B)}{\partial(\theta_V,\varphi_V)} = \left(1+\frac{\partial\lambda}{\partial\theta_{V}} \right) \left(1+\frac{\partial h}{\partial\varphi_{V}}\right)+ \frac{\partial h}{\partial\theta_{V}} \left(\iota-\frac{\partial\lambda}{\partial\varphi_{V}}\right) \]" src="form_76.png">
<p>
<p>
<br>
 The following methods perform transformation between the Boozer and VMEC coordinates:<br>
<br>
 <a class="el" href="classMConf_1_1CStconfig.html#332cf8154672d5e697c11687b3d3643a" title="The method transforms the VMEC coordinates to Boozer.">MConf::CStconfig::Vmec2Boozer()</a> <br>
 <a class="el" href="classMConf_1_1CStconfig.html#b4c9d5f55be0526b19b49a6e7fe99972" title="The method transforms the Boozer coordinates to VMEC.">MConf::CStconfig::Boozer2Vmec()</a> <br>
 <a class="el" href="classMConf_1_1CStconfig.html#13c116c659fa2709492341b5977000de" title="The method transforms the VMEC wout-file to Boozer-coordinate data file.">MConf::CStconfig::writeVmec2Boozer()</a> <br>
<p>
The example of how to transform the VMEC wout-file to Boozer-coordinate data file in <a class="el" href="W7X_Format.html">W7X format</a> is as follows <div class="fragment"><pre class="fragment"><span class="preprocessor">  #include "<a class="code" href="CStconfig_8h.html">CStconfig.h</a>"</span>
  <span class="keywordtype">int</span> main() {
    <a class="code" href="classMConf_1_1CStconfig.html" title="Magnetic configuration of a stellarator.">MConf::CStconfig</a> mConf;
    <span class="keywordflow">if</span>(!mConf.<a class="code" href="classMConf_1_1CStconfig.html#071b9a97170fd011e61fedaa0aae2dbc" title="The method loads the magnetic configuration stored in the file filename.">load</a>(<span class="stringliteral">"wout.w7x-sc1.txt"</span>)) exit(1);
    mConf.<a class="code" href="classMConf_1_1CStconfig.html#13c116c659fa2709492341b5977000de" title="The method transforms the VMEC wout-file to Boozer-coordinate data file.">writeVmec2Boozer</a>(<span class="stringliteral">"w7x-sc1.bc"</span>);
  }
</pre></div><p>
see also <a class="el" href="index.html#Gettingstarted">Getting started</a> and <a class="el" href="index.html#MinimalExample">Minimal example</a><p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h3><a class="anchor" name="Cyl2Mag">
Transformation from cylindrical to flux Coordinates</a></h3>
The formulas in section <a class="el" href="index.html#FluxCoordinates">Flux Coordinates</a> give prescription of how to find spatial position and magnetic field for point given in flux coordinates. However in most cases one need to know the flux surface label and the magnetic field at point given in cylindrical coordinates. Let us consider some examle. In pencil-beam approach the attenuation of the neutral beam injected into plasma can be described by the following equations<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{dI(l)}{dl} &amp; = &amp; -N_{e}(\mathbf{X})\sigma_{eff}I\\ \frac{d\mathbf{X}}{dl} &amp; = &amp; \mathbf{\hat{v}}_{b} \end{eqnarray*}" src="form_77.png">
<p>
<p>
where <img class="formulaInl" alt="$I$" src="form_78.png"> is the beam current, <img class="formulaInl" alt="$l$" src="form_79.png"> is the length along beam, <img class="formulaInl" alt="$N_{e}$" src="form_80.png">is the plasma density, <img class="formulaInl" alt="$\sigma_{eff}$" src="form_81.png">is the effective cross section, <img class="formulaInl" alt="$\mathbf{X}$" src="form_82.png">is the spatial position, <img class="formulaInl" alt="$\mathbf{\hat{v}}_{b}$" src="form_83.png">is the unit vector of beam direction. The second equation gives the beam trajectory in real space, though the plasma density or plasma profile <img class="formulaInl" alt="$N_{e}(s)$" src="form_84.png"> is given as a function of flux surface label <img class="formulaInl" alt="$s$" src="form_85.png"> or effective radius <img class="formulaInl" alt="$r_{eff}=a\sqrt{s}$" src="form_86.png"> ( <em>a</em> is the minor plasma radius). The coordinates transformation <img class="formulaInl" alt="$s(\mathbf{X})$" src="form_87.png"> from real space coordinates to the flux coordinates is needed in order to find plasma parameters along beam trajectory. This problem is common for plasma diagnostics, for pellet injection modeling, ECRH ray/beam tracing, NBI heating modeling.<h4><a class="anchor" name="NewtonMethod">
Newton method</a></h4>
To do the transformation from cylindrical coordinates <img class="formulaInl" alt="$(r_{0},\phi_{0},z_{0})$" src="form_88.png"> to the flux coordinates system <img class="formulaInl" alt="$\mathbf{u}=(u^{1},u^{2},u^{3})=(s,\theta,\varphi)$" src="form_89.png"> the following system has to be solved<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ 0=\mathbf{F}(\mathbf{u})\equiv \left[ \begin{array}{r} \sum R_{mn}(s)\cos\left(m\theta-nN_{p}\varphi\right)\;\;-r_{0}\\ \varphi-\frac{2\pi}{N_{p}}\sum\Phi_{mn}(s)\sin\left(m\theta-nN_{p}\varphi\right)\;-\phi_{0}\\ \sum Z_{mn}(s)\sin\left(m\theta-nN_{p}\varphi\right)\;\;-z_{0}\end{array} \right] \]" src="form_90.png">
<p>
<p>
Using initial guess <img class="formulaInl" alt="$\mathbf{u}_{k}$" src="form_91.png">, the correction <img class="formulaInl" alt="$\Delta\mathbf{u}_{k}$" src="form_92.png"> is calculated from the system obtained by Taylor expansion<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial\mathbf{F}(\mathbf{u}_{k})}{\partial\mathbf{u}_{k}} \Delta\mathbf{u}_{k}=-\mathbf{F}(\mathbf{u}_{k}) \]" src="form_93.png">
<p>
<p>
The solution is then found using iterations <p class="formulaDsp">
<img class="formulaDsp" alt="\[\mathbf{u}_{k+1}=\mathbf{u}_{k}+\gamma\!\Delta\mathbf{u}_{k}\]" src="form_94.png">
<p>
 where<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma=\Biggl\{\begin{array}{ll} 0.9\, s_{k}/\Delta s_{k} &amp; \textrm{if}\,\,(s_{k}+\Delta s_{k})<0\\ 1 &amp; \textrm{otherwise}\end{array} \]" src="form_95.png">
<p>
<p>
is the scale factor used to avoid negative flux label <em>s</em>.<p>
This method is fast and accurate. Basis vectors <img class="formulaInl" alt="$\partial\mathbf{X}/\partial u^{i}$" src="form_96.png"> and thus other quantities are available right after transformation. With a "good" guess only two or three iterations are needed to achieve accuracy of 0.1mm for W7-X magnetic configurations. The information from spatial points used in a previous coordinate transformations provides the good guess, for example during generating 3d-mesh or ray tracing. In cases when there is no information from nearest points available the library <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> uses rather slow root finder to compute the guess. The finder employs 2d-iterations on R-Z-plane.<p>
The figure below illustrates efficiency of the Newton method even in cases of "bad" guess. The iterations going from the guesses to solutions are shown.<p>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td><div align="center">
<img src="Newtonmethod02.png" alt="Newtonmethod02.png">
</div>
   </td></tr>
</table>
<br>
<p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h2><a class="anchor" name="Gettingstarted">
Getting started</a></h2>
This documentation is build with Doxygen which generates a lot of information that is useful for developer, but makes usual user confused. Naturally the question arises how to start to use <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> and which classes are really needed.<p>
In most cases you need only <a class="el" href="classMConf_1_1CStconfig.html" title="Magnetic configuration of a stellarator.">MConf::CStconfig</a> or <a class="el" href="classMConf_1_1C3dMesh.html" title="This class tabulates magnetic field, flux surface label, grad(s) on a 3d-mesh in...">MConf::C3dMesh</a><p>
<ul>
<li><a class="el" href="classMConf_1_1CStconfig.html" title="Magnetic configuration of a stellarator.">MConf::CStconfig</a> is the main class which implements geometric calculation. In particular, this class provides forth and back coordinate transformation between flux and real space coordinates.</li><li><a class="el" href="classMConf_1_1C3dMesh.html" title="This class tabulates magnetic field, flux surface label, grad(s) on a 3d-mesh in...">MConf::C3dMesh</a> is the class derived from CStconfig and all methods from CStconfig are available. In addition, C3dMesh tabulates magnetic field, flux surface label, grad(s) on a 3d-mesh in cylindrical coordinates and provides functions for interpolation. Use this class if you need fast coordinate mapping from real space to flux surface label. You can even do magnetic field line tracing.</li></ul>
<p>
You may also find the class <a class="el" href="classMConf_1_1CProfile.html" title="This class provides the plasma profile which can be set by set of points or parameterized...">MConf::CProfile</a> to be usefull.<p>
See also some <b><a href="examples.html" class="el">examples</a></b>.<p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h2><a class="anchor" name="MinimalExample">
Minimal example</a></h2>
This is a minimal example of how to use the CStconfig class.<p>
The steps are:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="CStconfig_8h.html">CStconfig.h</a>"</span>                          <span class="comment">//1. include the header file</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
{
  <span class="keyword">using namespace </span>MConf;                        <span class="comment">//2. MConf functions are in MConf namespace</span>
  
  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="cpp2for_8cpp.html#2675edd2140472f1d48c6178d4052018">degree</a> = 3.1415926535898/180;
  CStconfig mc;                                 <span class="comment">//3. Declare object</span>

  <span class="keywordflow">if</span>(<span class="keyword">false</span>==mc.load(<span class="stringliteral">"w7x-sc1.bc"</span>)) {            <span class="comment">//4. load into it magnetic configuration</span>
    std::cout &lt;&lt; <span class="stringliteral">"Loading error"</span>&lt;&lt;std::endl;
    <span class="keywordflow">return</span> 1;   <span class="comment">// exit if errors</span>
  }
  <span class="comment">//set point in cylindrical coord.</span>
  Vector3d cyl(6,1*degree,0.5);                 <span class="comment">//5. set point in real space</span>
  <span class="comment">// s is the normalized toroidal flux</span>
  <span class="keywordtype">double</span> s = mc.cyl2s(cyl);                     <span class="comment">//6. find flux label that corresponds to cyl</span>
  std::cout&lt;&lt;<span class="stringliteral">"cyl="</span>&lt;&lt;cyl&lt;&lt;<span class="stringliteral">"  s="</span>&lt;&lt;s&lt;&lt;std::endl; <span class="comment">//7. print results</span>
  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
Functions of MConf-library are defined in namespace <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a>, that is why <em>using namespace <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a></em> appears in step 2. However I would recommend not to use <em>using namespace</em> in your program. Otherwise you'll have problems in the future when someone (or even you) adds a symbol in other namespace and it will collide with one in yours. Using an individual class or function name (like <em>using Mconf::Vector3d;</em>) is okay, but don't do it at the file scope or a header file.<p>
See also other <b><a href="examples.html" class="el">examples</a></b>.<p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h2><a class="anchor" name="ObjectCanBeCopied">
Objects can be copied</a></h2>
<a class="el" href="classMConf_1_1CStconfig.html" title="Magnetic configuration of a stellarator.">MConf::CStconfig</a>, <a class="el" href="classMConf_1_1CRayTrace.html" title="Find intersections of straight ray with the flux surfaces, this class is obsolete...">MConf::CRayTrace</a>, and <a class="el" href="classMConf_1_1C3dMesh.html" title="This class tabulates magnetic field, flux surface label, grad(s) on a 3d-mesh in...">MConf::C3dMesh</a> objects internally use data sharing, so they can be cloned/copied without CPU time and memory overhead since only the pointers are copied (they are really smart). Writing to the clone object may take some time because the data referenced by the corresponding pointer is automatically cloned to preserve original instance of the object. The method is called "copy-on-write." With copy-on-write, two or more objects can share the same data until the moment when one of those objects is changed, at which point the data is physically copied and changed in one of the objects. This allows effective using of the MCONF in the multithreading programming.<p>
see also <a class="el" href="classMConf_1_1pBase_1_1ngArray.html" title="Array of objects.">MConf::pBase::ngArray</a> description.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "<a class="code" href="C3dMesh_8h.html">C3dMesh.h</a>"</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
{
  <a class="code" href="classMConf_1_1C3dMesh.html" title="This class tabulates magnetic field, flux surface label, grad(s) on a 3d-mesh in...">MConf::C3dMesh</a> mc1, mc2, mc3; <span class="comment">// C3dMesh is defined in MConf namespace</span>
                                <span class="comment">// the class is prefixed by namespace</span>
  m1.load(<span class="stringliteral">"filenameOfMesh.bin4"</span>);

  <span class="keywordflow">if</span>(mc1.<a class="code" href="classMConf_1_1C3dMesh.html#01a5dcb5ff3f1be025394cbfe73e2ab7" title="The method returns true if no error occurs during last operation.">isMeshOK</a>()==<span class="keyword">false</span>) {  <span class="comment">// create mesh if needed</span>
    mc1.<a class="code" href="classMConf_1_1C3dMesh.html#3ea78c39f10aeb7aa9c1241202df66dc" title="The method creates 3d-mesh in cylindrical coordinates.">createMeshUsingSymmetry</a> (0.02,0.02,2*degree);
    <span class="keywordflow">if</span>(<span class="keyword">false</span>==mc1.<a class="code" href="classMConf_1_1C3dMesh.html#01a5dcb5ff3f1be025394cbfe73e2ab7" title="The method returns true if no error occurs during last operation.">isMeshOK</a>()) exit(1);    <span class="comment">// exit if errors</span>
  }

  mc2 = mc1;                  <span class="comment">// This assignment is completely legal</span>
  mc3 = mc2;

  <a class="code" href="classMConf_1_1Vector3d.html" title="This class provides 3d-vector type.">MConf::Vector3d</a> c1(5),c2(5.1),c3(5.4);  

  <span class="keywordtype">double</span> s1 = mc1.<a class="code" href="classMConf_1_1CStconfig.html#8779c559cbf3003d7b847c93ce9dcd23" title="The method finds the flux label s which corresponds to the point in space.">cyl2s</a>(c1);  <span class="comment">// can be run in new execution thread, not shown here</span>
  <span class="keywordtype">double</span> s2 = mc2.<a class="code" href="classMConf_1_1CStconfig.html#8779c559cbf3003d7b847c93ce9dcd23" title="The method finds the flux label s which corresponds to the point in space.">cyl2s</a>(c2);  <span class="comment">// can be run in new execution thread</span>
  <span class="keywordtype">double</span> s3 = mc3.<a class="code" href="classMConf_1_1CStconfig.html#8779c559cbf3003d7b847c93ce9dcd23" title="The method finds the flux label s which corresponds to the point in space.">cyl2s</a>(c3);  <span class="comment">// can be run in new execution thread</span>

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>
The advantage of the code above is that the mesh is generated only once and then it can be used in different execution threads on a multi-processor systems with shared memory.<p>
This technique is used in <a class="el" href="classMConf_1_1C3dMesh.html#3ea78c39f10aeb7aa9c1241202df66dc" title="The method creates 3d-mesh in cylindrical coordinates.">MConf::C3dMesh::createMeshUsingSymmetry()</a>, <a class="el" href="classMConf_1_1CStconfig.html#465a68b1c3656d8a0f0231e7a9d9d20e" title="The method calculates and stores the eps_eff in the look-up table.">MConf::CStconfig::epsEffCreate()</a>, <a class="el" href="classMConf_1_1CStconfig.html#8cf5bd3cdb9f87645db7ae327a7c5a9a" title="The method calculates and stores the bootstrap current geometric factor in the look-up...">MConf::CStconfig::FbsCreate()</a>, in flux-surface averaging procedures and in NBI-code to run several NBI beams through plasma concurrently, see <a class="el" href="index.html#RelatedProjects">Related Projects</a> and <a class="el" href="threads_8h.html">threads.h</a><p>
<div class="no-print" align="right"><table border="0" cellspacing="3" cellpadding="3">
<tr>
<td>[ <a href="#TopOfPage" class="el">top</a> ] </td><td>[ <a href="#BottomOfPage" class="el">bottom</a> ] </td><td>[ <a href="javascript:history.back(-1);" class="el"><b>back</b></a> ]  </td></tr>
</table>
</div><div class="no-print"><hr>
</div><h2><a class="anchor" name="RelatedProjects">
Related Projects</a></h2>
<ul>
<li><b><a href="../docs-mcviewer/index.html" class="el">Magnetic Configuration viewer</a></b> displays a magnetic configuration and is written on a base of the <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> library. The MCviewer (<a class="el" href="Screenshots.html#MCviewer">sreenshoots</a>) is written in C++, using OpenGL library and the FLTK project (a cross-platform GUI library <a href="http://www.fltk.org/">http://www.fltk.org/</a> ). The FLTK library are distributed by its authors under the terms of the GNU Library General Public License (LGPL) with the exceptions, which do not require the author to provide source code of MCviewer.</li>
</ul>
<ul>
<li><a class="el" href="Screenshots.html#Travis">Travis</a> (stands for TRAce and VISualize) is the multi-beam multi-pass ray-tracing code for electron cyclotron heating and current drive calculations; it uses <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> library.</li>
</ul>
<ul>
<li><a class="el" href="Screenshots.html#NBIviewer">NBIviewer</a> is the code for Neutral Beam Injection heating simulation with the graphical user interface (GUI) front-end to the NBI-code; it uses <a class="el" href="namespaceMConf.html" title="Library namespace.">MConf</a> library.</li>
</ul>
<h2>Acknowledgments</h2>
<p>
The <a href="mailto:yuriy.turkinNOSPAMipp.mpg.de?body=Bitte NOSPAM in der Email-Adresse durch at-Zeichen ersetzen. 
- Please replace NOSPAM in the e-mail address by the at symbol." class="el">author</a> thanks H. Maa&szlig;berg, J. Geiger, C.D. Beidler, A. Dinklage, H. Dreier, Y. Feng, N. Marushchenko, M. Schmidt, J. Svensson, A. Werner for suggestions, contributions, helpful comments, and bug reports.<p>
 
<div><table border="0">
<tr> 
<td>Special thanks go to Dimitri van Heesch for his program&nbsp;&nbsp;<br> 
that has been used for producing this documentation.</td> 
<td><a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="right" border="0"></a></td> 
<td></td>
</tr>
</table></div>
<p>
<a class="anchor" name="BottomOfPage"></a> </div>
    <p><a class="anchor" name="BottomOfPage"></a></p>
    <div class="no-print" align="right">
      <table border="0">
        <tr>
        <td>[ <a class="el" href="#TopOfPage">top</a> ]</td>
        <td>[ <a class="el" href="javascript:history.back(-1);"><b>back</b></a> ]</td> 
        </tr>
      </table>
    </div>
    <hr class="separator">
    <div class="ippAddress" align="right">
      <table border="0">
        <tr>
          <td class="ippAddress">13 Oct 2021 &nbsp;&nbsp;&nbsp;&nbsp;</td>
          <td class="ippAddress">
            <a href="http://www.ipp.mpg.de"><img src="IPP.png" alt="www.ipp.mpg.de" border="0"></a>
          </td>
          <td class="ippAddress">
            <!-- Copyright &copy; 2005-2008<br> --> 
            Max-Planck-Institut<br>f&uuml;r Plasmaphysik
          </td>
        </tr>
      </table>
    </div>
  </div>
</div>
</body>
</html>
